robot "WallBot"

// WallBot: rushes to a random wall, then patrols along it. Reverses
// speed at corners instead of turning (instant direction change).
// Radar sweeps the arena-facing hemisphere when searching; locks onto
// enemy with tight oscillation when tracking (SawBot-style).
// On robot collision, switches to a different wall.

var wall int = 0
var phase int = 0
var patrolSpeed float = 70.0
var margin float = 55.0

// Radar sweep (search mode)
var radarSweepDir float = 1.0

// Enemy tracking
var enemyBearing angle = angle(0)
var enemyDist float = 0.0
var ticksSinceScan int = 999
var radarOscDir float = 1.0
var lockThreshold int = 20

func getPatrolHeading() angle {
	if wall == 0 || wall == 2 { return angle(90) }
	return angle(180)
}

func getInwardAngle() angle {
	if wall == 0 { return angle(180) }
	if wall == 1 { return angle(270) }
	if wall == 2 { return angle(0) }
	return angle(90)
}

func getRushHeading() angle {
	if wall == 0 { return angle(0) }
	if wall == 1 { return angle(90) }
	if wall == 2 { return angle(180) }
	return angle(270)
}

func distToWall() float {
	if wall == 0 { return getY() }
	if wall == 1 { return arenaWidth() - getX() }
	if wall == 2 { return arenaHeight() - getY() }
	return getX()
}

func init() {
	setColor(60, 180, 60)
	setGunColor(40, 100, 40)
	setRadarColor(100, 255, 100)
	setScanWidth(18.0)
	wall = random(4)
}

func tick() {
	ticksSinceScan = ticksSinceScan + 1

	if phase == 0 {
		// Rush to wall, decelerate as we approach to avoid wall damage
		setHeading(getRushHeading())
		d := distToWall()
		if d > 80.0 {
			setSpeed(90.0)
		} else {
			if d > 25.0 {
				setSpeed(35.0)
			} else {
				phase = 1
				setHeading(getPatrolHeading())
				patrolSpeed = 70.0
			}
		}
	}

	if phase == 1 {
		// Patrol along the wall, reverse speed at corners
		setHeading(getPatrolHeading())

		if wall == 0 || wall == 2 {
			if patrolSpeed > 0.0 && getX() > arenaWidth() - margin {
				patrolSpeed = patrolSpeed * -1.0
			}
			if patrolSpeed < 0.0 && getX() < margin {
				patrolSpeed = patrolSpeed * -1.0
			}
		}
		if wall == 1 || wall == 3 {
			if patrolSpeed > 0.0 && getY() > arenaHeight() - margin {
				patrolSpeed = patrolSpeed * -1.0
			}
			if patrolSpeed < 0.0 && getY() < margin {
				patrolSpeed = patrolSpeed * -1.0
			}
		}

		setSpeed(patrolSpeed)

		// If pushed off the wall, re-rush
		if distToWall() > 50.0 {
			phase = 0
		}
	}

	// Radar and gun behavior depends on whether we have a lock
	if ticksSinceScan < lockThreshold {
		// Tracking mode: tight radar lock on enemy, gun aims at enemy
		setScanWidth(12.0)
		enemyAbsAngle := getHeading() + enemyBearing
		radarTarget := enemyAbsAngle + angle(6.0) * radarOscDir
		setRadarHeading(radarTarget)
		radarOscDir = radarOscDir * -1.0

		setGunHeading(enemyAbsAngle)
	} else {
		// Search mode: wide sweep across arena-facing hemisphere
		setScanWidth(18.0)
		setRadarTurnRate(20.0 * radarSweepDir)
		inward := float(getInwardAngle())
		current := float(getRadarHeading())
		diff := current - inward
		if diff > 180.0 { diff = diff - 360.0 }
		if diff < -180.0 { diff = diff + 360.0 }
		if diff > 80.0 { radarSweepDir = -1.0 }
		if diff < -80.0 { radarSweepDir = 1.0 }

		setGunHeading(getRadarHeading())
	}

	debugInt(phase)
	debugFloat(enemyDist)
}

on wallHit(bearing angle) {
	if phase == 0 {
		phase = 1
		setHeading(getPatrolHeading())
		patrolSpeed = 70.0
	}
	if phase == 1 {
		patrolSpeed = patrolSpeed * -1.0
	}
}

on robotHit(bearing angle) {
	wall = (wall + 1 + random(3)) % 4
	phase = 0
	patrolSpeed = 70.0
}

on scan(distTo float, bearing angle) {
	enemyBearing = bearing
	enemyDist = distTo
	ticksSinceScan = 0

	if getGunHeat() == 0.0 {
		if distTo < 150.0 {
			fire(3.5)
		} else {
			if distTo < 350.0 {
				fire(2.0)
			} else {
				fire(1.0)
			}
		}
	}
}

on hit(damage float, bearing angle) {
	enemyBearing = bearing
	ticksSinceScan = 0
	patrolSpeed = patrolSpeed * -1.0
}
